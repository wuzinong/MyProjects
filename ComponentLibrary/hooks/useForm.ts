import * as React from 'react';
import { useState, useEffect } from 'react';
import { Validator } from 'src/components/form/Validators/Validators.types';

/** A warning or error, along with a descriptive message for the user. These are produced by
 * the field's _validators_, and the field's _validationState_ is dedided from the current list of issues.
 */
export interface Issue {
    type: 'info' | 'warning' | 'error' | 'initError';
    message: string;
}

/** The current state of the field, deduced from the issues returned by the form's validators. */
export type FieldValidationState = 'valid' | 'warning' | 'error' | 'initError';

/** React hook encapsulating the state and logic of a validated form field. */
export interface FormField<T> {

    /** The field's value  */
    value: T;

    /** Sets the field's value  */
    setValue: React.Dispatch<React.SetStateAction<T>>;

    /** The field's validation state (just a convenience, derived from the list of issues) */
    validationState: FieldValidationState;

    /** List of issues generated by running the current value through the field's validators */
    issues: Issue[];

    /** Has the field been interacted with yet? */
    touched: boolean;

    /** Set whether the field has been touched, if necessary. (Usually set automatically by setValue) */
    setTouched: React.Dispatch<React.SetStateAction<boolean>>;

    setParams:any;

    params:string[];
}

export function useFormField<T>(initialValue: T, validators: Validator<T>[]): FormField<T> {
    let [value, setValue] = useState<T>(initialValue);
    let [issues, setIssues] = useState<Issue[]>([]);
    let [validationState, setValidationState] = useState<FieldValidationState>('valid');
    let [touched, setTouched] = useState(false);
    let [params,setParams] = useState([]);
    function touchAndSetValue(value: T) {
        if (!touched) setTouched(true);
        setValue(value);
    }

    useEffect(() => {
        let newIssues: Issue[] = [];
        if (touched) {
            validators.forEach(validator => {
                let validationResult = validator.validate(value,params);
                if (!validationResult.isValid)
                    newIssues.push({ type: 'error', message: validationResult.message.toString() });
            });
        }else{
            //Handle init error
            validators.forEach(validator => {
                let validationResult = validator.validate(value,params);
                if (!validationResult.isValid)
                    newIssues.push({ type: 'initError', message: validationResult.message.toString() });
            });
        }

        let newValidationState: FieldValidationState;
        if (newIssues.some(x => x.type == 'error'))
            newValidationState = 'error';
        else if (newIssues.some(x => x.type == 'warning'))
            newValidationState = 'warning';
        else if (newIssues.some(x => x.type == 'initError'))
            newValidationState = 'initError'
        else
            newValidationState = 'valid';

        setIssues(newIssues);
        setValidationState(newValidationState);
    }, [value,touched,params]);

    return {
        value,
        params,
        setParams,
        setValue: touchAndSetValue,
        validationState,
        issues: touched ? issues : [], // for convenience, only expose issues after first interaction
        touched,
        setTouched
    };
}

/** The result of trying to submit the form. */
interface SubmitResult {
    values: any;
    success: boolean;
    failReason?: 'VALIDATION_FAILED' | 'ALREADY_SUBMITTED';
}

/** React hook that groups a set of FormFields into a form */
interface Form {

    /** The FormFields making up the form */
    fields: Record<string, FormField<any>>;

    /** Are all the fields valid? (State is not 'error') */
    allFieldsAreValid: boolean;

    /** Try to submit the form. If form is not valid, set all fields to 'touched',
     * so their validation issues are visible. You can also only submit once. */
    submit: () => Promise<SubmitResult>;

    /** Has the form been successfully submitted? If so, you can't submit again. */
    submitted: boolean;
}

export function useForm(fields: Record<string, FormField<any>>): Form {

    let [submitted, setSubmitted] = useState(false);

    let allFieldsAreValid = !Object.values(fields).some(field => field.validationState == 'error' || field.validationState == 'initError');

    async function submit(): Promise<SubmitResult> {

        // Touch all fields upon try submit, so they show their validation.
        Object.values(fields).forEach(field => field.setTouched(true));

        if (submitted) {
            return {
                values: null,
                success: false,
                failReason: 'ALREADY_SUBMITTED'
            }

        } else if (!allFieldsAreValid) {
            return {
                values: null,
                success: false,
                failReason: 'VALIDATION_FAILED'
            }

        } else {
            setSubmitted(true);

            let values = {};
            Object.keys(fields).forEach(key => values[key] = fields[key].value);
            return {
                values,
                success: true
            }
        }
    }

    return {
        fields,
        allFieldsAreValid,
        submit,
        submitted: submitted
    }
}